#!/usr/bin/perl
#
#
# generate Netdot::DBI from metadata provided by the DBMS
# and the Meta table(s)
# This should make changes in the schema less painful
#


use strict;
use DBI;

my $DB_TYPE        = $ARGV[0] || "mysql";
my $DB_DATABASE    = $ARGV[1] || "netdot";
my $DB_NETDOT_USER = $ARGV[2] || "netdot_user";
my $DB_NETDOT_PASS = $ARGV[3] || "netdot_pass";

my $out = "./DBI.pm";

open (OUT, ">$out")
    or die "Couldn't open $out: $!\n";

select (OUT);  # spit it all out to the output file by default

## In this chunk, we need variable interpolation (qq//)
my $head = 
qq ^package Netdot::DBI;
use base 'Class::DBI';
use Netdot::odHasMany;
use NetAddr::IP;

## This file was generated from a script.  Do not edit. ##

Netdot::DBI->set_db('Main', 'dbi:$DB_TYPE:$DB_DATABASE', '$DB_NETDOT_USER', '$DB_NETDOT_PASS');

sub VERSION { "0.6.4" }

^;

## No interpolation from now on (q//)

$head .= 
q [
__PACKAGE__->add_relationship_type( has_many => "Class::DBI::Relationship::odHasMany" );

  
##########################################
## Convert from IP address to integer
##########################################
sub ip2int {
    my $self = shift;
    my $ipobj;
    my $address = ($self->_attrs('address'))[0];
    unless ( $ipobj = NetAddr::IP->new($address) ){
	return $self->_croak(sprintf("Invalid IP address: %s", $address));
    }
    my $val = ($ipobj->numeric)[0];
    $self->_attribute_store( address => $val );
}

##########################################
## Convert from integer to IP address
##########################################
sub int2ip {
    my $self = shift;
    my ($address, $bin, $val);
    $address = $self->address;
# This is a hack to solve a (possible) bug in Class::DBI 0.96
# that causes the select trigger to be called twice, thus
# returning a bad result.
    return if ($address =~ /\D+/ );

    if ($self->version == 4){
	$val = (new NetAddr::IP $address)->addr();
    }elsif ($self->version == 6) {
	# This code adapted from Net::IP::ip_inttobin()

	require Math::BigInt;

	my $dec = new Math::BigInt $address;
	my @hex = (0..9,'a'..'f');
	my $ipv6 = "";

	# Set warnings off, use integers only (loathe Math::BigInt)
	local $^W = 0;
	use integer;
	foreach my $i (0..31)	# 32 hex digits in 128 bits
	{
	    # There is colon separating every group of 4 hex digits
	    $ipv6 = ':' . $ipv6 if ($i > 0 and $i % 4 == 0);
	    # Last hex digit is in low 4 bits
	    $ipv6 =  $hex[$dec % 16] . $ipv6;
	    # Chop off low 4 bits
	    $dec /= 16;
	}
	no integer;
	
	# Use the compressed version
	$val = (new NetAddr::IP $ipv6)->short();
    }elsif (defined $self->version){
	return $self->_croak(sprintf("Invalid IP version:", $self->version));
    }else {
	return $self->_croak(sprintf("Ipblock id %s (%s) has no version", $self->id, $address ));
    }
    $self->_attribute_store( address => $val );    
}

#################################################
# Copy stored object in history table.
# We use DBI directly to avoid CDBI returning
# the object in memory
################################################
sub historize {
    my $self = shift;
    my $table = $self->table;
    my $h_table = "$table" . "_history";
    return unless eval { $h_table->table }; #history table might not exist
    my (%current_data, $new_h_obj);
    my $dbh = Netdot::DBI->db_Main();
    my $col_list = join ",", $table->columns;
    my $id = $self->id;
    my @vals = $dbh->selectrow_array("SELECT $col_list FROM $table WHERE id = $id");
    my $i = 0;
    map { $current_data{$_} = $vals[$i++] } $table->columns;
    delete $current_data{id}; # Our id is different
    my ($seconds, $minutes, $hours, $day_of_month, $month, $year,
	$wday, $yday, $isdst) = localtime;
    my $datetime = sprintf("%04d\/%02d\/%02d %02d:%02d:%02d",
			   $year+1900, $month+1, $day_of_month, $hours, $minutes, $seconds);
    my $oid = lc("$table" . "_id");
    $current_data{$oid} = $self->id;
    $current_data{modified} = $datetime;
    my $user = $ENV{REMOTE_USER} || "unknown";
    $current_data{modifier} = $user;
    eval { $new_h_obj = $h_table->create(\%current_data) };
    if ( $@ ){
	$self->_croak( $@ );
    }
}

################################################################
# validate_phys_addr - Perform validation of MAC address strings
# 
# String must look like "DEADDEADBEEF".
# Assumes that "000000000000", "111111111111" ... "FFFFFFFFFF" 
# are invalid.
#
# Arguments: address string
# Returns:   True if valid, False if invalid
#
################################################################
sub validate_phys_addr {
    my ($self, $addr) = @_;
    if ( $addr !~ /^[0-9A-F]{12}$/ ||
	 # Assume the all-equal-bits address is invalid
	 ($addr =~ /^([0-9A-F]{1})/ && $addr =~ /$1{12}/)  ){
	return 0;
    }
    return 1;
}

#################################################
# Canonicalize MAC addresses before inserting.
# Search methods will also need to convert to
# this format prior to searching.
################################################
sub canonicalize_phys_addr {
    my $self = shift;
    my $address = ($self->_attrs('address'))[0];
    $address =~ s/[:\.\-]//g;
    $address = uc($address);
    unless ($self->validate_phys_addr($address)){
	$self->_croak("Invalid Address: $address");	
    }
    $self->_attribute_store( address => $address );
}

Ipblock->add_trigger( deflate_for_create => \&ip2int );
Ipblock->add_trigger( deflate_for_update => \&ip2int );
Ipblock->add_trigger( select => \&int2ip );

PhysAddr->add_trigger( deflate_for_create => \&canonicalize_phys_addr );
PhysAddr->add_trigger( deflate_for_update => \&canonicalize_phys_addr );

__PACKAGE__->add_trigger( before_update => \&historize );


#################################################
# These are specific SQL queries tailored to
# some of Netdot's classes' needs
# The syntax for calling them looks like
#   <Tablename>->search_<key>
# e.g.  
#   Ipblock->search_children
################################################

# Short way to retrieve all the ip addresses from a device
# 
# Apparently one can't bind the "ORDER BY" parameter :-(
#
Ipblock->set_sql(devipsbyaddr => qq{
    SELECT Device.id, Interface.id, Interface.name, Interface.device, Ipblock.id, Ipblock.interface, Ipblock.address
	FROM Ipblock, Interface, Device
	WHERE Interface.id = Ipblock.interface AND
	Device.id = Interface.device AND
	Device.id = ?
	ORDER BY Ipblock.address
    });
Ipblock->set_sql(devipsbyint => qq{
    SELECT Device.id, Interface.id, Interface.name, Interface.device, Ipblock.id, Ipblock.interface, Ipblock.address
	FROM Ipblock, Interface, Device
	WHERE Interface.id = Ipblock.interface AND
	Device.id = Interface.device AND
	Device.id = ?
	ORDER BY Interface.name
    });

# Get lists of products
Product->set_sql(bytype => qq{
    SELECT p.name, p.id, COUNT(d.id) AS numdevs
	FROM Device d, Product p, ProductType t
	WHERE d.productname = p.id AND
	p.type = t.id AND
	t.id = ?
	GROUP BY p.id
	ORDER BY numdevs DESC
    });

Product->set_sql(notype => qq{
    SELECT p.name, p.id, COUNT(d.id) AS numdevs
	FROM Device d, Product p
	WHERE d.productname = p.id AND
	p.type = 0
	GROUP BY p.id
	ORDER BY numdevs DESC
    });

Product->columns(TEMP => qw/numdevs/);

];	# End huge q() quote

print $head;

my $dbh = DBI->connect ("dbi:$DB_TYPE:$DB_DATABASE", "$DB_NETDOT_USER", "$DB_NETDOT_PASS")
    or die "Can't connect to db: $DBI::errstr\n";

my @tables = $dbh->tables;
map { $_ =~ s/\`//g } @tables;

foreach my $table (@tables){
    print ("\n\n######################################################################\n");
    print "package $table;\n";
    print "use base 'Netdot::DBI';\n";
    print "__PACKAGE__->table( '$table' );\n";
    my $sth = $dbh->prepare("SELECT * FROM $table");
    $sth->execute;
    my ($i, %cols, @tmp);
    for ($i = 0; $i < $sth->{NUM_OF_FIELDS}; $i++){
	$cols{$sth->{NAME}->[$i]} = '';
    }
    
    print "__PACKAGE__->columns( Primary => qw / id /);\n";
    delete $cols{id};
    my $hist = 1 if ($table =~ s/_history//);
    @tmp = split /,/, 
       $dbh->selectrow_array("SELECT columnorderbrief FROM Meta WHERE name='$table'");
    delete $cols{$_} foreach (@tmp);

    my $essential = join ' ', @tmp;
    print "__PACKAGE__->columns( Essential => qw / $essential /);\n" if scalar(@tmp);

    my $others = join ' ', keys %cols;
    print "__PACKAGE__->columns( Others => qw / $others /);\n" if scalar (keys %cols);

    my @hasALn = $dbh->selectrow_array("SELECT linksto FROM Meta WHERE name='$table'");
    my @hasManyLn = $dbh->selectrow_array("SELECT linksfrom FROM Meta WHERE name='$table'");

    foreach my $line (@hasALn){
	my @items = split /,/, $line;
	foreach my $item (@items){
	    my ($col, $tab) = split /:/, $item;
	    print "__PACKAGE__->has_a( $col => '$tab' );\n";
	}
    }
    unless ( $hist ){
      foreach my $line (@hasManyLn){
	my @items = split /,/, $line;
	    foreach my $item (@items){
		my @fields = split /:/, $item; 
		my $numfields = scalar @fields;
		if ($numfields == 3){
		    my ($meth, $tab, $col) = split /:/, $item; 
		    print "__PACKAGE__->has_many( '$meth', '$tab' => '$col' );\n";
		}elsif ($numfields == 4){
		    my ($meth, $tab, $col, $args) = split /:/, $item; 
		    print "__PACKAGE__->has_many( '$meth', '$tab' => '$col', $args );\n";
		}else{
		    print STDERR "ERROR!: Incorrect number of fields: $numfields, in linksfrom for table $table\n";
		    print STDERR "fields are: ", join (', ', @fields), "\n";
		    print STDERR "$0: exited abnormally\n";
		    exit;
		}
	    }
      }
   } 
}


print "\n#Be sure to return 1\n";
print "1;\n";

close (OUT);
