#
# Make the necessary modifications to upgrade Netdot's schema and data
#
use strict;
use lib "../lib";
use DBUTIL;
use Netdot;
use Netdot::Model;

my %CONFIG;
$CONFIG{olddb}             = 'netdot-0712';
$CONFIG{debug}             = 1;
$CONFIG{keep_history}      = 1;
$CONFIG{keep_dependencies} = 0;

foreach my $var ( qw /DB_TYPE DB_HOME DB_HOST DB_PORT DB_DBA DB_DBA_PASSWORD 
		  DB_NETDOT_USER DB_NETDOT_PASS DB_DATABASE/ ){
    $CONFIG{$var} = Netdot->config->get($var);
}


my $olddbh = &dbconnect($CONFIG{DB_TYPE}, $CONFIG{DB_HOST}, $CONFIG{DB_PORT}, 
			$CONFIG{DB_DBA}, $CONFIG{DB_DBA_PASSWORD}, $CONFIG{olddb});

my $newdbh = &dbconnect($CONFIG{DB_TYPE}, $CONFIG{DB_HOST}, $CONFIG{DB_PORT}, 
			$CONFIG{DB_DBA}, $CONFIG{DB_DBA_PASSWORD}, $CONFIG{DB_DATABASE});


my %table_skips = (
    'BinFile'       => 1,
    'ClosetPicture' => 1,
    'FloorPlan'     => 1,
    'InterfaceDep'  => 1,
    'Meta'          => 1,
    );

my %table_renames = ( 
    'NetConnection'         => 'sitelink',
    'NetConnection_history' => 'sitelink_history',
    );

my %field_skips = (
    'Device'           => { 
	'natted'         => 1,
	'maint_covered'  => 1,
	'part_of'        => 1,
    },
    'Device_history'   => { 
	'natted'         => 1,
	'maint_covered'  => 1,
	'part_of'        => 1,
    },
    'Entity' => {
	'type' => 1,
    },
    'Entity_history' => {
	'type' => 1,
    },
    'Ipblock' => {
	'dns_delegated' => 1,
	'physaddr'      => 1,
    },
    'RR' => {
	'contactlist'   => 1,
	'origin'        => 1,
    },
    'Vlan' => {
	'subnet' => 1,
    }
    );

my %field_renames = (
    'Circuit'          => { 'connectionid' => 'linkid'    },
    'Circuit_history'  => { 'connectionid' => 'linkid'    },
    'Closet'           => { 
	'110_blocks'   => 'ot_blocks',
	'66_blocks'    => 'ss_blocks'  
    },
    'Closet_history' => { 
	'110_blocks'   => 'ot_blocks',
	'66_blocks'    => 'ss_blocks' 
    },
    'Device' => { 
	'lastupdated'   => 'last_updated',
	'dateinstalled' => 'date_installed',
	'productname'   => 'product',
    },
    'Device_history' => { 
	'lastupdated'   => 'last_updated',
	'dateinstalled' => 'date_installed',
	'productname'   => 'product',
    },
    'NetConnection_history' => { 
	'connection_id'   => 'sitelink_id',
    );

foreach my $oldtable ( $olddbh->tables() ){
    
    $oldtable =~ s/`//g;
    $oldtable =~ s/$CONFIG{olddb}\.//;

    if ( $oldtable =~ /_history/ ){
	if ( !$CONFIG{keep_history} ){
	    &debug("Ignoring history table: $oldtable");
	    next;
	}
    }

    my $newtable;
    
    if ( exists $table_skips{$oldtable} ){
	next;
    }elsif ( exists $table_renames{$oldtable} ){
	$newtable = $table_renames{$oldtable};
    }else{
	# New database has all lowercase table names
	$newtable = lc($oldtable);
    }
    
    &debug("oldtable: $oldtable");
    &debug("newtable: $newtable");
    
    # overwrite default data
    &debug("Deleting all rows from $newtable");
    $newdbh->do("DELETE FROM $newtable");
    
    # Get column metadata
    my $mtable = Netdot->meta->get_table($newtable) 
	|| die "Cannot get table metadata for $newtable";
    my $class = $mtable->name;
    my %meta_columns;
    map { $meta_columns{$_->name} = $_ } $class->meta_data->get_columns;
    
    &debug("Inserting data into $newtable");
    my $sth = $olddbh->prepare("SELECT * FROM $oldtable");
    $sth->execute();
    my @statements;
    while ( my $href = $sth->fetchrow_hashref() ){
	my %args;
	foreach my $field ( keys %$href ){
	    my $f;
	    if ( exists $field_renames{$oldtable}{$field} ){
		$f = $field_renames{$oldtable}{$field};
	    }elsif ( exists $field_skips{$oldtable}{$field} ){
		next;
	    }else{
		$f = $field;
	    }
	    # Metacolumn object
	    my $mcol = $meta_columns{$f};
	    die "Cannot get metadata for column $f in table $newtable\n"
		unless defined $mcol && ref($mcol);

	    my $value = $href->{$field};
	    if ( !defined $value && !$mcol->is_nullable && $mcol->sql_type =~ /integer|bool/i ){
		$args{$f} = 0;
	    }else{
		$args{$f} = $value;
	    }
	}
	my $fields = join (',', keys %args);
	my $values = join (',', map { $newdbh->quote($_) } values %args);
	push @statements, "INSERT INTO $newtable ($fields) VALUES ($values);";
    }
    &processdata($newdbh, \@statements);
}

#####################
# Special Cases
#####################

#####################
# ClosetPicture

my $bf = $olddbh->selectall_arrayref("SELECT id, bindata, filename, filesize, filetype, info
                                      FROM BinFile
                                     ");
my %map;
foreach my $row ( @$bf ){
    my ($id, $bindata, $filename, $filesize, $filetype, $info) = @$row;
    next unless ($bindata && $filename && $filesize && $filetype);
    $map{$id}{bindata}  = $bindata;
    $map{$id}{filename} = $filename;
    $map{$id}{filesize} = $filesize;
    $map{$id}{filetype} = $filetype;
    $map{$id}{info}     = $info;
}
my $cp = $olddbh->selectall_arrayref("SELECT id, closet, binfile FROM ClosetPicture");

my $st = $newdbh->prepare("INSERT INTO closetpicture (closet,bindata,filename,filesize,filetype,info)
                           VALUES (?,?,?,?,?,?);");

$newdbh->do("DELETE FROM closetpicture");
foreach my $row ( @$cp ){
    my ($id, $closet, $binfile) = @$row;
    my $data = $map{$binfile};
    unless ( $data ){
	&debug("closetpicture $id refers to unexistent binfile $binfile");
	next;
    }
    
    $st->execute($closet, $data->{bindata}, $data->{filename}, $data->{filesize}, $data->{filetype}, $data->{info});
}

#####################
# EntityRole

my @statements;
my $ent = $olddbh->selectall_arrayref("SELECT id, type FROM Entity");
&debug("Inserting existing Entity types into EntityRole");
foreach my $row ( @$ent ){
    my ($id, $type) = @$row;
    push @statements, "INSERT INTO entityrole (entity,type) VALUES ($id,$type);";
}
&processdata($newdbh, \@statements);

#####################
# Mark all interfaces as snmp
$newdbh->do("UPDATE interface SET doc_status='snmp';");

#####################
# Insert missing default data
$newdbh->do("INSERT INTO ipblockstatus (name) VALUES ('Discovered');");

#####################
# Get rid of 'na' value for admin_duplex and oper_duplex
# (has undesired effects on duplex mismatch finder)
$newdbh->do("UPDATE interface SET admin_duplex=NULL WHERE admin_duplex='na';");
$newdbh->do("UPDATE interface SET oper_duplex=NULL WHERE oper_duplex='na';");

# Set all devices to SNMPv2 by default
$newdbh->do("UPDATE device SET snmp_version=2 WHERE snmp_managed=1");

&dbdisconnect($olddbh);
&dbdisconnect($newdbh);


sub debug {
    print STDERR "DEBUG: ", @_, "\n" if $CONFIG{debug};
}
