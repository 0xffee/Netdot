<%doc>

Common header for all pages

</%doc>
%
<%args>
$title
$section
$user
$showheader
</%args>
%
%
<%init>
my %caller_args = $m->caller_args(-1);
my $page = "";

my $hideheader;
if( !$showheader ) {
    $hideheader = 'style="display:none"';
}

# This is the stuff that varies in the different sections of the
# navbar.  The next natural step would be to move this data into the
# sections themselves (mason attributes or methods).  Notice that
# section, attribute, and page could probably be unified into a single
# string (use upcase to make attribute upcase if upcase is wanted.
# append ``section_'' and ``.html'' to page).

# Arrays are used, as opposed to, say, keying on ``section'', because
# arrays order there entries
my $section_meta_data = [
    {   section => 'Reports',
	page => 'section_reports.html',
	title => 'Reports',
	attribute => 'REPORTS_PAGE',
	sub_sections => [
	    { section => 'DEVICE', title => 'Device Inventory' },
	    { section => 'CUSTOM', title => 'Custom Reports' },
	    { section => 'DATABASE', title => 'Database Reports' },
	]
    },
    {   section => 'Help',
        page => 'section_help.html',
        title => 'Help',
        attribute => 'HELP_PAGE',
        sub_sections => []
    },
];

# Here we add the meta_data for the (factored out) management section.
# It provides its own metadata in a method.  An attribute could have
# been used, but we might as well keep it flexible (attributes are
# pretty limited).  If all the meta data was factored out we would
# build the meta data list here in the order we wanted the sections to
# appear.
unshift @{ $section_meta_data }, 
    map { $m->comp("/$_/autohandler:.section_meta_data") }
        ("management", "operations", "cable_plant", "generic");
</%init>
%
%
<%def .make_section>
    <%doc>
    Makes a section\'s link given the sections meta data
    </%doc>
%
%
    <%args>
    $section
    $current_section
    $meta_data
    %caller_args
    $user
    </%args>
%
%
    <%init>
    my $sub_section_html = "";
    my $class_html = "";
    my $page = "";
    if ( $section eq $current_section ) {
        $class_html = qq(class="current");
	if ( exists($caller_args{page}) ) {
	    $user->setAttribute($r, $meta_data->{attribute}, $caller_args{page});
        }
	eval { $page = $user->getAttribute($meta_data->{attribute}) };
	if ($@) {
	    $m->comp( "error.mhtml", error => <<HERE );

You have just encountered a bug which currently has us stumped.
Please report in detail what you were doing around the time the error
occured (e.g. if you were eating lunch what kind of lettuce did you
have on your sandwhich) and tell us what time netdot says it is right
now (upper right corner).  Thanks.

The perl error was\:
$@
HERE
	}
        # Build a link for each subsection
	for my $sub_section (@{ $meta_data->{sub_sections} }) {
	    # Need to specify these paths absolutely, since they are
	    # top level (above the individual subsections). $r->dir_config('NetdotPath') .
	    my $target = $r->dir_config('NetdotPath') . $meta_data->{page};
	    my $title = $sub_section->{title};
	    my $class_html = ($page eq $sub_section->{section} || $page eq "") ?
			     qq(class="subnav_selected") : "";
	    $sub_section_html .= 
		qq(<li><a href="$target?page=@{[ $sub_section->{section} ]}" $class_html>$title</a></li>\n)
	    }
    }
    </%init>
%
%
    <a href="<% $r->dir_config('NetdotPath') . $meta_data->{page} %>" <% $class_html %>><% $meta_data->{title} %></a>\
%   if ($sub_section_html ne "") {
    <ul id="subnavigation">
    <% $sub_section_html %>
    </ul>
%   }
</%def>
%
%
<div id="navbar" <% $hideheader %>>
    <ul id="navigation">
%   for my $meta_data (@{ $section_meta_data }) { 
        <& .make_section, current_section => $meta_data->{section},
	   meta_data => $meta_data,
           caller_args => \%caller_args, page => $page, %ARGS &>\
%   }
    </ul>
</div>
