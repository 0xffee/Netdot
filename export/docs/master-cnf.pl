#!/usr/bin/perl

# Generate a text file with a simple list of Devices
# with their types, ip addresses and parents (uplink devices),
# grouped by the building their located in and their subnet
#
# 
use lib "/usr/local/netdot/lib";
use Netdot::Export;
use Netdot::DBI;
use strict;
use Getopt::Long;

use vars qw( %self $USAGE %types %hosts %entities %ip2name %name2ip );


&set_defaults();

my $USAGE = <<EOF;
usage: $0 --dir <DIR> --out <FILE>

    --dir             <path> Path to configuration file
    --out             <name> Configuration file name (default: $self{out})
    --debug           Print debugging output
    --help            Display this message

EOF

&setup();
&gather_data();
&build_configs();


##################################################
sub set_defaults {
    %self = ( 
	      dir             => '',
	      out             => 'master.cnf',
	      help            => 0,
	      debug           => 0, 
	      );

}

##################################################
sub setup{
    
    my $result = GetOptions( 
			     "dir=s"            => \$self{dir},
			     "out=s"            => \$self{out},
			     "debug"            => \$self{debug},
			     "h"                => \$self{help},
			     "help"             => \$self{help},
			     );
    
    if( ! $result || $self{help} ) {
	print $USAGE;
	exit 0;
    }

    unless ( $self{dir} && $self{out} ) {
	print "ERROR: Missing required arguments\n";
	die $USAGE;
    }

    %types = (
	      'Access Point'     => 'access-point', 
	      'DSL Modem'	 => 'dsl-modem',
	      'Firewall'         => 'host',
	      'Hub'		 => 'hub',
	      'IP Phone'	 => 'host',
	      'Packet Shaper'	 => 'host',
	      'Router'           => 'router',
	      'Server'	         => 'host',
	      'Switch'	         => 'switch',
	      'Wireless Bridge'  => 'access-point',
	      'Wireless Gateway' => 'access-point',
	      );
}

##################################################
sub gather_data{

    my $it = Ipblock->retrieve_all();
    while ( my $ip = $it->next ){
	next if $ip->address =~ /^127\.0\.0/;
	next unless ( $ip->prefix == 32 || $ip->prefix == 128);
	my ($type, $site, $entity);
	
	if ( $ip->interface->device ){
	    my $address = $ip->address;

	    if ( $ip->interface->device->productname &&
		 $ip->interface->device->productname->type){

		$type = $ip->interface->device->productname->type->name;
		if (exists $types{$type}){
		    $type = $types{$type};
		}else{
		    $type = "host";
		}
	    }else{
		$type = 'host';
		warn "Can't figure out type for Device with ip $address" if $self{debug};
	    }
	    if ( $ip->interface->device->site ){
		my $s = $ip->interface->device->site;
		$site = $s->name;
		$site = join '_', split /\s+/, $site;
	    }else{
		$site = 'unknown';
		warn "Can't determine site for Device with ip $address" if $self{debug};
	    }
	    if ( $ip->interface->device->used_by ){
		my $e = $ip->interface->device->used_by;
		$entity = $e->name;
		$entity = join '_', split /\s+/, $entity;
		$entities{$entity}{id} = $e->id;
	    }else{
		$entity = 'unknown';
		$entities{$entity}{id} = 0;
		warn "Can't determine entity for Device with ip $address" if $self{debug};
	    }
	}else{
	    warn "Can't determine Device from ip ", $ip->address if $self{debug};
	    next;
	}
	
	my $name;
	unless ( ($name = &resolve($ip->address)) && !exists $name2ip{$name} ){
	    $name = $ip->interface->device->name 
		. "-" . $ip->interface->name
		. "-" . $ip->address;
	    warn "Assigned name $name \n" if $self{debug};
	}
	$name2ip{$name} = $ip->id;
	$ip2name{$ip->id} = $name;
	$hosts{$ip->address}{type} = $type;
	$hosts{$ip->address}{name} = $name;
	push @{ $entities{$entity}{site}{$site}{hosts} }, $ip->address;
	
    }

    # Now that we have all the names
    foreach my $ipid ( keys %ip2name ){
	
	my $ipobj = Ipblock->retrieve($ipid);
	
	my $parentlist =  join ',', map { $ip2name{$_} } 
	map { ($_->ips)[0] }  map { $_->parent }  $ipobj->interface->parents;
	
	if ( $parentlist ){
	    $hosts{$ipobj->address}{parents} = $parentlist;
	}else{
	    $hosts{$ipobj->address}{parents} = "NULL";
	}
    }
}

##################################################
sub build_configs {

    my $filename = "$self{dir}/$self{out}";
    open (FILE, ">$filename") or die "Couldn't open $filename for writing: $!\n";
    select (FILE);

    print "#            ****        THIS FILE WAS GENERATED FROM A DATABASE         ****\n";
    print "#            ****           ANY CHANGES YOU MAKE WILL BE LOST            ****\n";
    print "#  Generated by $0 on ", scalar(localtime), "\n\n\n";

    foreach my $entity ( sort keys %entities ){
	
	print "############################################################################################################################\n";
	print "network               $entity                      NULL\n";
	print "############################################################################################################################\n";
	
	print "\n";
	
	if ( my $entobj = Entity->retrieve($entities{$entity}{id}) ){
	    foreach my $subnet ($entobj->used_blocks){
		print "prefix                 ", $subnet->address, "/", $subnet->prefix, "\n";
	    }
	}
	
	print "\n";
	
	foreach my $site ( sort keys %{$entities{$entity}{site}} ){
	    my $oldhandle = select FILE;
	    $~ = "HOSTLIST";
	    select ($oldhandle);
	    
	    print "building               $site\n";
	    foreach my $ipadd (sort @{$entities{$entity}{site}{$site}{hosts}} ){
		
		# Define a format for the host list
		
		format HOSTLIST = 
@<<<<<<<<<<<<<<<<<<<<<<@<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<@<<<<<<<<<<<<<<<<<<<@<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
$hosts{$ipadd}{type}, $hosts{$ipadd}{name}, $ipadd, $hosts{$ipadd}{parents}
.
    write ;
}

           $oldhandle = select FILE;
           $~ = "FILE";
           select ($oldhandle);
           print "\n";
       }
    }
}
