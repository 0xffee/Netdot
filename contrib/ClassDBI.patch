*** DBI.pm	2003-07-02 03:48:40.000000000 -0700
--- DBI-with-on_delete.pm	2003-07-08 16:05:06.000000000 -0700
***************
*** 74,79 ****
--- 74,80 ----
  #----------------------------------------------------------------------
  __PACKAGE__->mk_classdata('__AutoCommit');
  __PACKAGE__->mk_classdata('__hasa_list');
+ __PACKAGE__->mk_classdata('_on_delete_list');
  __PACKAGE__->mk_classdata('_table');
  __PACKAGE__->mk_classdata('_table_alias');
  __PACKAGE__->mk_classdata('sequence');
***************
*** 612,620 ****
  
  sub delete {
  	my $self = shift;
  	return $self->_search_delete(@_) if not ref $self;
  	$self->call_trigger('before_delete');
! 	$self->_cascade_delete;
  
  	eval { $self->sql_DeleteMe->execute($self->id) };
  	if ($@) {
--- 613,642 ----
  
  sub delete {
  	my $self = shift;
+ 	my $class = ref($self);
  	return $self->_search_delete(@_) if not ref $self;
  	$self->call_trigger('before_delete');
! 	my %cascade = %{ $class->__hasa_list || {} };
! 	my %on_delete = %{ $class->_on_delete_list || {} };
! 	foreach my $remote (keys %cascade){
! 		my $f_key = $cascade{$remote};
! 		if ($on_delete{$remote} eq "restrict"){
! 			if ( scalar $remote->search($f_key => $self->id) ){
! 				return $self->_croak(
! 					"$remote objects exist that refer to this object.  Deletion restricted."
! 				);
! 			}
! 		}elsif ($on_delete{$remote} eq "set-null"){
! 			$self->_cascade_set_null($remote, $f_key);
! 		}elsif ($on_delete{$remote} eq "cascade"){
! 			$self->_cascade_delete($remote, $f_key);
! 		}else {
! 			return $self->_croak(
! 				"Unknown on_delete behavior: $on_delete{$remote}"
! 			);
! 		}
! 	}
! 
  
  	eval { $self->sql_DeleteMe->execute($self->id) };
  	if ($@) {
***************
*** 634,647 ****
  }
  
  sub _cascade_delete {
! 	my $self    = shift;
  	my $class   = ref($self);
! 	my %cascade = %{ $class->__hasa_list || {} };
! 	foreach my $remote (keys %cascade) {
! 		$_->delete foreach $remote->search($cascade{$remote} => $self->id);
  	}
  }
  
  # Return the placeholder to be used in UPDATE and INSERT queries. Usually
  # you'll want this just to return '?', as per the default. However, this
  # lets you set, for example, that a column should always be CURDATE()
--- 656,676 ----
  }
  
  sub _cascade_delete {
!         my ($self, $remote, $f_key) = @_;
          my $class = ref($self);
!         $_->delete foreach $remote->search($f_key => $self->id);
! }
! 
! sub _cascade_set_null {
!         my ($self, $remote, $f_key) = @_;
!         my $class   = ref($self);
!         foreach ( $remote->search($f_key => $self->id) ){
!                 $_->set($f_key, 0);
!                 $_->update;
          }
  }
  
+ 
  # Return the placeholder to be used in UPDATE and INSERT queries. Usually
  # you'll want this just to return '?', as per the default. However, this
  # lets you set, for example, that a column should always be CURDATE()
***************
*** 1145,1156 ****
--- 1174,1189 ----
  
  	$f_key ||= $class->table_alias;
  
+         # Make "cascade" the default behavior
+         $args->{on_delete} ||= "cascade";
+ 
  	if (ref $f_key eq "ARRAY") {
  		return $class->_croak("Multiple foreign keys not implemented")
  			if @$f_key > 1;
  		$f_key = $f_key->[0];
  	}
  	$class->_extend_hasa_list($f_class => $f_key);
+         $class->_extend_on_delete_list($f_class => $args->{on_delete});
  
  	{
  
***************
*** 1210,1215 ****
--- 1243,1254 ----
  	$class->_extend_class_data(__hasa_list => @_);
  }
  
+ sub _extend_on_delete_list {
+         my $class = shift;
+         $class->_extend_class_data(_on_delete_list => @_);
+ }
+ 
+ 
  #----------------------------------------------------------------------
  # might have
  #----------------------------------------------------------------------
***************
*** 1321,1327 ****
  		print $track->position, $track->title
  	}
  
! 	$cd->delete; # also deletes the tracks
  
  	my $cd  = Music::CD->retrieve(1);
  	my @cds = Music::CD->retrieve_all;
--- 1360,1366 ----
  		print $track->position, $track->title
  	}
  
! 	$cd->delete; # also deletes the tracks (can be modified)
  
  	my $cd  = Music::CD->retrieve(1);
  	my @cds = Music::CD->retrieve_all;
***************
*** 1622,1630 ****
  	Music::CD->delete(year => 1980, title => 'Greatest %');
  
  Deletes this object from the database and from memory. If you have set up
! any relationships using has_many, this will delete the foreign elements
! also, recursively (cascading delete).  $obj is no longer usable after
! this call.
  
  If called as a class method, deletes all objects matching the search
  criteria given.  Each object found will be deleted in turn, so cascading
--- 1661,1669 ----
  	Music::CD->delete(year => 1980, title => 'Greatest %');
  
  Deletes this object from the database and from memory. If you have set up
! any relationships using has_many, this will take into account the "on_delete" 
! parameter (optional) passed to the has_many method (see the has_many section below).
! $obj is no longer usable after this call.
  
  If called as a class method, deletes all objects matching the search
  criteria given.  Each object found will be deleted in turn, so cascading
***************
*** 2320,2325 ****
--- 2359,2379 ----
  		return map $_->style, $self->_style_refs;
  	}
  
+ =head3 Behavior at delete time
+ 
+         CD->has_many('tracks', 'Track' => 'cd', { on_delete => 'restrict' });
+ 
+ You can specify what the delete method should do when the object being deleted has
+ associated objects.  The options are:
+ 
+ 'cascade':   Will delete the associated objects also, recursively (cascading delete).
+              This is the default.
+ 
+ 'set-null':  The foreign keys of the associated objects will be set to null.
+ 
+ 'restrict':  The delete method will return with an error, notifying that there are
+ 	     associated objects and deletion is not permitted.
+ 
  =head2 might_have
  
  	Music::CD->might_have(method_name => Class => (@fields_to_import));
