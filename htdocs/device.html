<%perl>
my %args;
foreach my $j ( keys %ARGS ) {
  next if( $ARGS{$j} !~ /\w+/ );
  $args{$j} = $ARGS{$j};
}
if( exists( $args{comstr} ) ) {
  $comstr = $args{comstr};
}
if( $args{device} && ! $args{sid} ) {
  $session = $gui->mksession( $TMP );
}
if( $args{sid} ) {
  $session = $gui->getsession( $TMP, $args{sid} );
}
if( $args{cancel} ) {
  $gui->rmsession( $session );
}


if( exists( $args{insert} ) ) {
  my %device = %{ $session->{device} };
  
  if( Device->search( name => "$args{device}" ) 
      || Device->search( physaddr => $device{dot1dBaseBridgeAddress} ) ) {
    ; # do nothing
  } else {
    my( %tmp, $newdevice );
    my @ifrsv = NvIfReserved->retrieve_all();
    $tmp{name} = $args{device};
    $tmp{community} = $comstr;
    $tmp{sysdescription} = $device{sysDescr};
    unless( $device{dot1dBaseBridgeAddress} eq "noSuchObject" ) {
      # Remove the '0x' from the MAC address
      $device{dot1dBaseBridgeAddress} =~ s/^0x//;
      $tmp{physaddr} = $device{dot1dBaseBridgeAddress};
    }
    unless( $device{entPhysicalSerialNum} eq "noSuchObject" ) {
      $tmp{serialnumber} = $device{entPhysicalSerialNum};
    }
    # Try to guess some values
    if ($tmp{name} =~ /hub/){
      my $typeid = (DeviceType->search(name => "Hub"))[0];     
      $tmp{type} = $typeid;
    }elsif ($tmp{name} =~ /switch/ || $tmp{name} =~ /backbone/){
      my $typeid = (DeviceType->search(name => "Switch"))[0];     
      $tmp{type} = $typeid;
    }elsif ($tmp{name} =~ /-gw/ || $tmp{name} =~ /router/ ){
      my $typeid = (DeviceType->search(name => "Router"))[0];     
      $tmp{type} = $typeid;
    }elsif ($tmp{name} =~ /-ap/){
      my $typeid = (DeviceType->search(name => "Access Point"))[0];     
      $tmp{type} = $typeid;
    }else{
      $tmp{type} = 0;
    }
    $tmp{component_type} = "0"; 
    $tmp{productname} = "0"; 
    $tmp{part_of} = "0"; 
    $tmp{site} = "0"; 
    $tmp{contactlist} = "0"; # same
    $tmp{user} = "0"; # same
    $tmp{entity} = "0"; # same
    $tmp{managed} = "1"; # same
    eval { $newdevice = Device->create( \%tmp ); }
      or die "Unable to create device $args{device}: $@ \n";
    $inserted = $newdevice->id;
    foreach my $int ( keys %{ $device{interface} } ) {
      my $skip = 0;
      foreach my $rsv ( @ifrsv ) {
        my $n = $rsv->name;
        $skip = 1 if( $int =~ /$n/ );
      }
      next if( $skip );
      next if( Interface->search
                 ( device => $newdevice->id,
                   number => $device{interface}{$int}{instance} ) );
      undef( %tmp );
      $tmp{device} = $newdevice->id;
      $tmp{name} = $int;
      $tmp{managed} = "1";
      foreach my $dbname ( keys %ifnames ) {
	if( $ifnames{$dbname} eq "descr" ) {
	  if( $device{interface}{$int}{$ifnames{$dbname}} ne "-" ) {
	    $tmp{$dbname} = $device{interface}{$int}{$ifnames{$dbname}};
	  }
	} elsif ($dbname eq "physaddr"){
	    $device{interface}{$int}{$ifnames{$dbname}} =~ s/^0x//;
	    $tmp{$dbname} = $device{interface}{$int}{$ifnames{$dbname}};
	}else {
	  $tmp{$dbname} = $device{interface}{$int}{$ifnames{$dbname}};
	}
      }
      my $if;
      eval { $if = Interface->create( \%tmp ); }
        or die "Unable to create Interface $int: $@\n";
      undef( %tmp );
      if( exists( $device{interface}{$int}{ipAdEntIfIndex} ) ) {
         foreach my $ip ( keys %{ $device{interface}{$int}{ipAdEntIfIndex} } ) {
            my( $subnet, %iptmp, %nettmp );
	    $iptmp{interface} = $if->id;
            $iptmp{address} = $ip;
            $iptmp{mask} = $device{interface}{$int}{ipAdEntIfIndex}{$ip};
            $tmp{subnet} = 0;
            my $decip = unpack('N', (pack ('C*', split (/\./, $ip))));
            my $decmask = unpack('N', (pack ('C*', split (/\./, $iptmp{mask}))));
            my $net = inet_ntoa(pack('N',$decip & $decmask));
	    if( $subnet = (Subnet->search( address => $net ) )[0] ) {
              $iptmp{subnet} = $subnet->id;
	    } else {
	      $nettmp{address} = $net;
	      $nettmp{entity} = 0;
	      #eval { $subnet = Subnet->create( \%nettmp ); }
              #  or die "Unable to create Subnet $net: $@\n";
              $iptmp{subnet} = 0;
 	    }
	    # 
	    if( Ip->search( address => $ip ) ) {
              ;
            } else {
              eval { Ip->create( \%iptmp ); }
                or die "Unable to create IP $ip: $@\n";
            }
         }
      }
    }
    $gui->rmsession( $session );
  }
}
</%perl>
% if( $inserted ) {
  <& view.html, table => "Device", id => $inserted &>
% } else {
<& header, title => "Device" &>
<!-- device.html -->
<br>
<blockquote>
<form action="device.html" method="POST">
<table>
<tr>
<td ALIGN="LEFT">Device</td><td ALIGN="LEFT">Community</td>
</tr>
<tr>
<td><input type="text" name="device" size="30" value="<% $args{device} %>"></td>
<td><input type="text" name="comstr" size="30" value="<% $comstr %>"></td>
</tr>
</table>
<input name="submit" value="Discover" type="submit">
</form>
</blockquote>
%   if( exists( $args{cancel} ) ) {
%     ;
%   } elsif( exists( $args{insert} ) ) {
<hr>
%     # check to see if device already exists in Device table
%     my %device = %{ $session->{device} };
%     my $id;
%     if( ($id = (Device->search( name => "$args{device}" ))[0])
%         || ($id = (Device->search( physaddr => $device{dot1dBaseBridgeAddress}))[0] ) ) {
        <p>Device <a href="view.html?table=Device&id=<% $id %>"><% $args{device} %></a> already exists in Device table.
%     }
%   } elsif( exists( $args{device} ) ) {
<hr>
<p><% $args{device} %>
%     $nv->build_config( "device", $args{device}, $comstr );
%     if( my( %device ) = $nv->get_device( "device", $args{device}, $comstr ) ) {
%       if( keys %{ $device{interface} } ) {
%         $session->{device} = \%device;
    <form>
    <input type="hidden" name="sid" value="<% $session->{_session_id} %>">
    <input type="hidden" name="device" value="<% $args{device} %>">
    <input type="hidden" name="comstr" value="<% $comstr %>">
    <table cellpadding="3" cellspacing="1" border="0">
    <tr align="LEFT">
    <td bgcolor="#FFFFFF" align="CENTER" colspan="3">
    <input name="insert" value="Submit" type="submit">
    </td>
    <td>
    <input name="cancel" value="Cancel" type="submit">
    </td>
    </tr>
    </table>
    </form>
%         printf "<pre>%s</pre>\n", Dumper( \%device ) if( $DEBUG );
%         print "<code><pre>", $nv->string_config( "device", $args{device} ), "</pre></code>\n";
%       } else {
%         if( exists( $args{sid} ) && defined( $session ) ) {
%           $gui->rmsession( $session );
%         }
    <p>Failed to get details.
%       }
%     } else {
%       if( exists( $args{sid} ) && defined( $session ) ) {
%         $gui->rmsession( $session );
%       }
    <p>Failed to build information.
%     }
%   }
<& footer &>
% }
<%args>
$comstr => "public"
$DEBUG => 0
$TMP => "/home/netdot/public_html/tmp"
$nv => Netdot::Netviewer->new()
$gui => Netdot::GUI->new()
$session => undef
$inserted => 0
%ifnames => ( physaddr => "ifPhysAddress", number => "instance", type => "ifType", description => "descr", speed => "ifSpeed", status => "ifAdminStatus" )
</%args>

<%init>
use Netdot::Netviewer;
use Socket;

</%init>
<%doc>

Device discovery & updates

######################################################################
#  $Log: node.html,v $
#  Revision 1.29  2003/07/21 15:00:58  netdot
#  Revised the 0x removal and did the same for the interfaces -- cv
#
#  Revision 1.28  2003/07/17 06:08:04  netdot
#  making sure comstr is used and propagated
#
#  Revision 1.27  2003/07/17 05:34:36  netdot
#  use $comstr in build_config!
#
#  Revision 1.26  2003/07/17 02:41:12  netdot
#  Removed the 0x from physaddr
#
#  Revision 1.25  2003/07/17 02:24:00  netdot
#  Set user and contactlist to '0' --cv
#
#  Revision 1.24  2003/07/17 00:03:53  netdot
#  *** empty log message ***
#
#  Revision 1.23  2003/07/16 22:37:18  netdot
#  disabling chunk of subnet code for later work
#
#  Revision 1.22  2003/07/15 19:08:30  netdot
#  fixed code for skipping interfaces
#
#  Revision 1.21  2003/07/15 15:51:46  netdot
#  added community for Node
#
#  Revision 1.20  2003/07/14 23:35:46  netdot
#  added code for optional community string
#
#  Revision 1.19  2003/07/12 21:13:23  netdot
#  more updates and checks; interfaces, ips, subnets, etc.
#
#  Revision 1.18  2003/07/12 18:34:51  netdot
#  more fixes; cancel works and added series of eval statements
#
#  Revision 1.17  2003/07/11 21:34:38  netdot
#  *** empty log message ***
#
#  Revision 1.16  2003/07/10 00:09:14  netdot
#  fixed latest bug; still need to add subnet code
#
#  Revision 1.15  2003/07/09 21:56:04  netdot
#  *** empty log message ***
#
#  Revision 1.14  2003/07/09 21:24:09  netdot
#  *** empty log message ***
#
#  Revision 1.13  2003/07/08 22:44:01  netdot
#  added code to insert ip addresses
#
#  Revision 1.12  2003/07/03 23:24:04  netdot
#  *** empty log message ***
#
#  Revision 1.11  2003/07/03 23:12:04  netdot
#  more fixes:
#    * be sure to check Reserved IFs
#    * check whether base address is already
#
#  Revision 1.10  2003/07/03 21:31:33  netdot
#  fix so that call to view.html works
#
#  Revision 1.9  2003/07/03 21:18:16  netdot
#  state and insertion stuff works; still need to fix some stuff
#  (eg. when device does not respond)
#
#  Revision 1.8  2003/07/03 00:38:39  netdot
#  blah
#
#  Revision 1.7  2003/07/01 05:27:40  netdot
#  work to introduce state for final push
#
#  Revision 1.6  2003/06/17 23:23:58  netdot
#  *** empty log message ***
#
#  Revision 1.5  2003/06/17 00:03:11  netdot
#  bugger if i know
#
#  Revision 1.4  2003/06/12 23:50:06  netdot
#  more work -- probably moving to create.html
#
#  Revision 1.3  2003/06/12 00:52:58  netdot
#  *** empty log message ***
#
#  Revision 1.2  2003/06/11 22:43:55  netdot
#  working on integrating netviewer & netdot
#
#  Revision 1.1  2003/06/11 16:19:21  netdot
#  Initial revision
#

</%doc>
