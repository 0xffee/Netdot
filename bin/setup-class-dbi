#!/usr/bin/perl
#
#
# generate Netdot::DBI from metadata provided by the DBMS
# and the Meta table(s)
# This should make changes in the schema less painful
#


use strict;
use DBI;

my $DB_TYPE = $ARGV[0] || "mysql";
my $DB_DATABASE = $ARGV[1] || "netdot";
my $DB_NETDOT_USER = $ARGV[2] || "netdot_user";
my $DB_NETDOT_PASS = $ARGV[3] || "netdot_pass";

my $out = "./DBI.pm";

open (OUT, ">$out")
    or die "Couldn't open $out: $!\n";

select (OUT);  # spit it all out to the output file by default

## In this chunk, we need variable interpolation (qq//)
my $head = 
qq ^package Netdot::DBI;
use base 'Class::DBI';
use Net::IP qw(:PROC);
use Netdot::odHasMany;

## This file was generated from a script.  Do not edit. ##

Netdot::DBI->set_db('Main', 'dbi:$DB_TYPE:$DB_DATABASE', '$DB_NETDOT_USER', '$DB_NETDOT_PASS');

sub VERSION { "0.5" }

^;

## No interpolation from now on (q//)

$head .= 
q ^
__PACKAGE__->add_relationship_type( has_many => "Class::DBI::Relationship::odHasMany" );

  
##########################################
## Convert from IP address to integer
##########################################
sub ip2int {
    my $self = shift;
    my $ipobj;
    my $address = ($self->_attrs('address'))[0];
    unless ( $ipobj = NetAddr::IP->new($address) ){
	return $self->_croak(sprintf("Invalid IP address: %s", $address));
    }
    my $val = ($ipobj->numeric)[0];
    $self->_attribute_store( address => $val );
}


##########################################
##########################################
## Convert from integer to IP address
##########################################
sub int2ip {
    my $self = shift;
    my ($address, $bin, $val);
    $address = $self->address;
    return if ($address =~ /\D+/ );  #(*)
    if ($self->version == 4){
	$bin = ip_inttobin($address, 4);
	$val = ip_bintoip($bin, 4);
    }elsif ($self->version == 6) {
	$bin = ip_inttobin($address, 6);
	$val = ip_compress_address(ip_bintoip($bin, 6), 6);
    }elsif (defined $self->version){
	return $self->_croak(sprintf("Invalid IP version:", $self->version));
    }else {
	return $self->_croak(sprintf("Ipblock id %s (%s) has no version", $self->id, $address ));
    }
    $self->_attribute_store( address => $val );    
}

# (*) This is a hack to solve a (possible) bug in Class::DBI 0.96
# that causes the select trigger to be called twice, thus
# returning a bad result.

Ipblock->add_trigger( deflate_for_create => \&ip2int );
Ipblock->add_trigger( deflate_for_update => \&ip2int );
Ipblock->add_trigger( select => \&int2ip );

##########################################
## Insert object in history table
##########################################
    
__PACKAGE__->
  add_trigger( 
	      before_update=>
	       sub {
		   my $self = shift;
		   my $class = ref ($self);
		   my (%current_data, $new_h_obj, $oid);
		   my $user = $ENV{REMOTE_USER} || "unknown";
		   my $dbobj = ( $class->retrieve_from_sql(qq{
		       id = "$self->id"
		   }) )[0];
		   foreach my $col ($self->columns){
		       next if ($col eq 'id');
		       $current_data{$col} = $dbobj->$col;
		   }
		   my $table = ref($self);
		   my $h_table = "$table" . "_history";
		   $oid = lc("$table" . "_id");
		   return unless eval { ## h_table might not exist
		       $new_h_obj = $h_table->create(\%current_data);
		       1;
		   };
		   $new_h_obj->set($oid, $self->id);
		   $new_h_obj->set("modifier", $user);
		   my ($seconds, $minutes, $hours, $day_of_month, $month, $year,
		       $wday, $yday, $isdst) = localtime;
		   my $datetime = sprintf("%04d\/%02d\/%02d %02d:%02d:%02d",
					  $year+1900, $month+1, $day_of_month, $hours, $minutes, $seconds);
		   $new_h_obj->set("modified", $datetime);
		   $new_h_obj->update;
	       }
	     );


^;

print $head;

my $dbh = DBI->connect ("dbi:$DB_TYPE:$DB_DATABASE", "$DB_NETDOT_USER", "$DB_NETDOT_PASS")
    or die "Can't connect to db: $DBI::errstr\n";

my @tables = $dbh->tables;
map { $_ =~ s/\`//g } @tables;

foreach my $table (@tables){
    print ("\n\n######################################################################\n");
    print "package $table;\n";
    print "use base 'Netdot::DBI';\n";
    print "__PACKAGE__->table( '$table' );\n";
    my $sth = $dbh->prepare("SELECT * FROM $table");
    $sth->execute;
    my ($i, %cols, @tmp);
    for ($i = 0; $i < $sth->{NUM_OF_FIELDS}; $i++){
	$cols{$sth->{NAME}->[$i]} = '';
    }
    
    print "__PACKAGE__->columns( Primary => qw / id /);\n";
    delete $cols{id};
    @tmp = split /,/, 
       $dbh->selectrow_array("SELECT columnorderbrief FROM Meta WHERE name='$table'");
    delete $cols{$_} foreach (@tmp);

    my $essential = join ' ', @tmp;
    print "__PACKAGE__->columns( Essential => qw / $essential /);\n" if scalar(@tmp);

    my $others = join ' ', keys %cols;
    print "__PACKAGE__->columns( Others => qw / $others /);\n" if scalar (keys %cols);

    my @hasALn = $dbh->selectrow_array("SELECT linksto FROM Meta WHERE name='$table'");
    my @hasManyLn = $dbh->selectrow_array("SELECT linksfrom FROM Meta WHERE name='$table'");

    foreach my $line (@hasALn){
	my @items = split /,/, $line;
	foreach my $item (@items){
	    my ($col, $tab) = split /:/, $item;
	    print "__PACKAGE__->has_a( $col => '$tab' );\n";
	}
    }
    foreach my $line (@hasManyLn){
	my @items = split /,/, $line;
	    foreach my $item (@items){
		my @fields = split /:/, $item; 
		my $numfields = scalar @fields;
		if ($numfields == 3){
		    my ($meth, $tab, $col) = split /:/, $item; 
		    print "__PACKAGE__->has_many( '$meth', '$tab' => '$col' );\n";
		}elsif ($numfields == 4){
		    my ($meth, $tab, $col, $args) = split /:/, $item; 
		    print "__PACKAGE__->has_many( '$meth', '$tab' => '$col', $args );\n";
		}else{
		    print STDERR "ERROR!: Incorrect number of fields: $numfields, in linksfrom for table $table\n";
		    print STDERR "fields are: ", join (', ', @fields), "\n";
		    print STDERR "$0: exited abnormally\n";
		    exit;
		}
	    }
    }
}


print "\n#Be sure to return 1\n";
print "1;\n";

close (OUT);
