<%perl>
##################################################
#
# BEGIN PRE PROCESSING
#
##################################################

##################################################
# clean out old state files
$gui->rmsessions( $TMP, $AGE );

##################################################
# grab arguments to this script
my %rev = reverse %ARGS;
foreach my $j ( keys %ARGS ) {
  ################################################
  # in case apache makes the value an array, set to last value
  if( ref( $ARGS{$j} ) eq "ARRAY" ) {
    my @t = @{ $ARGS{$j} };
    $ARGS{$j} = $t[$#t];
  }
  if( $ARGS{$j} eq "New" ) {
    $TBL = $j;
    $TBL =~ s/^_//;
    $NEW = 1;
    next;
  }
  next if( $j !~ /\w+/ );

# Ignore fields that don't belong to the table
# /_srch/ elements are added for javascript only
# we don't need them here

  next if ($j =~ /_srch/ );
   
# "/^_/" is added to avoid using reserved words in javascript
# chop it off
  my $k = $j;
  $k =~ s/^_//;
  $args{$k} = $ARGS{$j};	   
}

##################################################
# define TBL (if not already) and set previous table for reference
if( $TBL && $args{table} ) {
  $PREV = $args{table}
} elsif( ! defined( $TBL ) ) {
  $TBL = $args{table};
}
unless( defined( $PREV ) ) {
  $PREV = $TBL;
}

##################################################
# get state back if sid defined
#   otherwise create state if necessary
if( defined( $args{sid} ) ) {
  $sid = $args{sid};
  $session = $gui->getsession( $TMP, $sid );
} elsif( $args{table} ) {  
  $session = $gui->mksession( $TMP );
  $sid = $session->{_session_id};
}

##################################################
if( $DEBUG && 0 ) {
  print "ARGS: ";
  printf "<pre>%s</pre>\n", Dumper( \%ARGS );
  print "SESSION: ";
  printf "<pre>%s</pre>\n", Dumper( $session );
}

##################################################
# if Cancel, go back to last state
if( $args{cancel} eq "Cancel" ) {
  if( $args{create} ) {
    $TBL = $args{create};
    delete( $args{create} );
  } else {
    if( ! defined( $session->{path} ) || length( $session->{path} ) < 1 ) {
      $gui->rmsession( $session );
      $TBL = $PREV;
    } else {
      $TBL = $gui->popsessionpath( $session );
    }
  }
}

##################################################
# fill in the rest of state details -- for Submit or New
if( exists( $args{submit} ) 
    || exists( $rev{New} ) || exists( $args{discover} ) ) {
  foreach my $arg ( keys %args ) {
    next if( $arg eq "submit" || $arg eq "sid" || $arg eq "commit"
             || $arg eq "table" || $arg eq "commit" );
    next if( length( $arg ) < 1 || ! defined( $args{$arg} ) );
    $session->{tables}{$PREV}{$arg} = $args{$arg};
  }
  if( ! defined( $args{submit} ) ) {
    $gui->pushsessionpath( $session, $args{table} );
  }
}

if( exists( $args{submit} ) ) {
  $session->{foo} = "bar";
}
if( exists( $args{confirm} ) ) {
  $session->{foo} = "bar2";
}

##################################################
# get back some history of where user has clicked
if( exists( $args{submit} ) || exists( $args{confirm} ) ) {
  ################################################
  # if user hits reload after a 'Confirm' (and we're displaying a table
  #   form submit page), we need to be sure we go back to the proper
  #   table/object page and do not create empty objects in the DB.
  if( $args{confirm} && ! exists( $session->{tables}{ $args{create} } ) ) {
      print "deleting Confirm\n";
    delete( $args{confirm} );
    ##############################################
    # get sessionpath and look for table not in session{tables}
    # push that table onto sessionpath
    my ( $x, %z );
    map { $z{$_} = 1 } split( /;/, $session->{path} );
    foreach my $y ( keys %{ $session->{tables} } ) {
      if( ! exists( $z{$y} ) ) {
        $x = $y;
      }
    }
    $gui->pushsessionpath( $session, $x );
  }
  ################################################
  # if not a submit, pop last table from sessionpath
  if( ! exists( $args{submit} ) ) {
    my $tmp = $gui->popsessionpath( $session );
    if( defined( $tmp ) && length( $tmp ) > 0 ) {
      $TBL = $tmp;
    }
  }
}

##################################################
# get id and object now that TBL is set finally
if( exists( $args{id} ) ) {
  if( ! $NEW ) {
    $ID = $ARGS{id};
  }
} elsif( exists( $session->{tables}{$TBL}{id} ) ) {
  $ID = $session->{tables}{$TBL}{id}
}
if( $ID ) {
  if( $TBL ) {
    $OBJ = $TBL->retrieve($ID); 
  } elsif( $args{confirm} eq "Confirm" && $args{create} ) {
    $OBJ = $args{create}->retrieve($ID);
  }
}

##################################################
# if confirm, handle here
if( $args{confirm} eq "Confirm" ) {
  my( $T, $r );
  $T = $args{create};
  if( $OBJ && ( ! $TBL || $T eq $TBL ) ) {  # we're updating an object
    $r = $gui->update( object => $OBJ, state => \%{ $session->{tables}{$T} } );
  } else {
    $r = $gui->insert( table => $T, state => \%{ $session->{tables}{$T} } );
  }
  if( ! $r ) {
    my $err = $gui->error;
    die "Error: $err";
  }
  delete( $session->{tables}{ $args{create} } );
  if( length( $session->{path} ) < 1 && ! defined( $TBL ) ) {
    if( defined( $session ) ) {
      $gui->rmsession( $session );
    }
  }
  $session->{created}{$T} = $r;
  ################################################
  # reset ID and OBJ if appropriate (ie. no more edit/creates left)
  if( ! $TBL || $args{cancel} ) {
    $ID = $r;
    $OBJ = $T->retrieve($ID);
  } else {
    undef( $ID );
  }
}

##################################################
# create %state to pass to form
# only if ID not set since we want form component to fill that in
if( defined( $TBL ) && ! defined( $ID ) ) {
  my $meta = $gui->getmeta( $TBL );
  my %lt = $gui->getlinksto( $TBL );
  foreach my $c ( split( /,/, $meta->columnorder ) ) {
    if( $args{$c} ) {
      $state{$c} = $args{$c};
    }
  }
  if( exists( $session->{tables}{$TBL} ) ) {
    foreach my $c ( keys %{ $session->{tables}{$TBL} } ) {
      if( $lt{$c} && $session->{created}{$lt{$c}} ) {
        $state{$c} = $session->{created}{$lt{$c}};
      } else {
        $state{$c} = $session->{tables}{$TBL}{$c};
      }
    }
  }
}
</%perl>
% ################################################
% #
% # END PRE PROCESSING
% # BEGIN HTML
% #
% ################################################

% ####################################################################
% if( $DEBUG ) {
    table : <% $args{table} %> ; TBL : <% $TBL %><br>
    id : <% $ID %><br>
    PREV : <% $PREV %> <br>
    ARGS :
%   printf "<pre>%s</pre>\n", Dumper( \%ARGS );
    SESSION: 
%   printf "<pre>%s</pre>\n", Dumper( $session );
    <hr>
% }

<& edit_html, args => \%args, id => $ID, table => $TBL, obj => $OBJ, sid => $sid, session => $session, state => \%state &>


% ####################################################################
<%args>
$DEBUG => 0
$NEW => 0
$TBL => undef
$PREV => undef
$ID => undef
$OBJ => undef
$sid => undef
$TMP => "/home/netdot/public_html/tmp"
$AGE => 86400
$session => undef
$gui => Netdot::GUI->new()
%args => undef
%order => undef
%linksto => undef
</%args>

<%init>
my %state;
undef( %state );
</%init>

<%doc>
edit.html

  Arguments:

    table -- name of table to create/edit
    id    -- row in a specific table if editing
    sid   -- session id (used for keeping state while creating objects)
    cancel - cancels all existing state and returns to null state
    submit - 
    (column names from any/all tables)

  Possible states:

    - null 
    new page to create any table

    - table is set
    present page to create that table

    - table and id are set
    present page to edit particular instance of that table

    - user clicked New on a table page
    present page to create object for New; keep state for previous 
    table page
    push PREV table name onto sessionpath

    - cancel
    user clicks on cancel; clear all state

    - submit
    Table has been submitted to be added/updated; go to Confirm page.

    - confirm
    User has confirmed instance to be submitted; submit changes to DB;
    pop table from sessionpath for table to go back to (if necessary).

  Variables:

    $PREV - name of previously viewed/edited table
    $TBL  - name of current table
    $ID   - integer for specific row in table $TBL
            Used to determine when we are editing a table
    $OBJ  - the object instantiation of $ID in $TBL
    $sid  - session id; cookie to get back state as we go through several 
            web pages.  Peformed using Apache::Session::File
    $TMP  - where Apache::Session::File should store its lock and state files
    $AGE  - maximum age of said files
    $WIDTH - number of columns to be displayed in default state
    $session - object holding state
    $gui  - instantiation of Netdot::GUI
    %args - parts of %ARGS I want 
    %order - hash of column -> rank to list tables in
    %linksto - hash of column -> Table listings of current table
               which columns point to other tables
    
    $DEBUG - whether to show debug information
</%doc>
